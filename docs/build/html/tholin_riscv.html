<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tholin’s RISC-V &mdash; GFMPW-1-Multi  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=5929fcd5"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="https://wavedrom.com/skins/default.js"></script>
        <script src="https://wavedrom.com/wavedrom.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Rejunity’s Designs" href="rejs_designs.html" />
    <link rel="prev" title="UE14500" href="ue14500.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            GFMPW-1-Multi
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Overview</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="multiplexer.html">Multiplexer</a></li>
<li class="toctree-l1"><a class="reference internal" href="qcpu.html">QCPU MCU</a></li>
<li class="toctree-l1"><a class="reference internal" href="mc14500.html">MC14500</a></li>
<li class="toctree-l1"><a class="reference internal" href="ue14500.html">UE14500</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tholin’s RISC-V</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pinout">Pinout</a></li>
<li class="toctree-l2"><a class="reference internal" href="#memory-bus">Memory Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="#peripherals">Peripherals</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#serial-ports">Serial ports</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gpio-port">GPIO Port</a></li>
<li class="toctree-l3"><a class="reference internal" href="#timers">Timers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#interrupts">Interrupts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#external-interrupt">External Interrupt</a></li>
<li class="toctree-l3"><a class="reference internal" href="#timer-1-interrupt">Timer 1 Interrupt</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uart-interrupt">UART Interrupt</a></li>
<li class="toctree-l3"><a class="reference internal" href="#registers">Registers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-iret-instruction">The <code class="docutils literal notranslate"><span class="pre">iret</span></code> instruction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-sei-instruction">The <code class="docutils literal notranslate"><span class="pre">sei</span></code> instruction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-cli-instruction">The <code class="docutils literal notranslate"><span class="pre">cli</span></code> instruction</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#custom-settings">Custom Settings</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="rejs_designs.html">Rejunity’s Designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="diceroll.html">Diceroll</a></li>
<li class="toctree-l1"><a class="reference internal" href="blinker.html">LED Blinker</a></li>
<li class="toctree-l1"><a class="reference internal" href="tbb1143.html">TBB1143</a></li>
<li class="toctree-l1"><a class="reference internal" href="sid.html">SID</a></li>
<li class="toctree-l1"><a class="reference internal" href="as11.html">AS-11</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GFMPW-1-Multi</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Tholin’s RISC-V</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/tholin_riscv.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="tholins-risc-v">
<span id="tholin-riscv"></span><h1>Tholin’s RISC-V<a class="headerlink" href="#tholins-risc-v" title="Link to this heading"></a></h1>
<p>This project is a RV32IM CPU core intended to deliver high performance through high memory throughput despite the limited number of IO pins. Normally, CPU designs on caravel have to either use slow serial memories or put RAM on-die, both of which are suboptimal due to low memory speed and low memory capacity respectively.</p>
<p>An attempt is made here to solve this and provide a relatively high-speed memory interface at the cost of only just over half of the <code class="docutils literal notranslate"><span class="pre">mprj_io</span></code> pins and moderately increased board complexity.</p>
<p>Note, however, that this CPU was not made to be pipelined due to time constraints and thus does not offer the theoretically highest possible performance, but should still be superior in memory-bound applications.</p>
<section id="pinout">
<h2>Pinout<a class="headerlink" href="#pinout" title="Link to this heading"></a></h2>
<img alt="_images/pinout10.png" src="_images/pinout10.png" />
<table class="docutils align-default" id="pin-description-riscv">
<caption><span class="caption-number">Table 8 </span><span class="caption-text">Pin description</span><a class="headerlink" href="#pin-description-riscv" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Pin #</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Summary</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">mprj_io[0]</span></code></p></td>
<td><p>RSTD</p></td>
<td><p>I</p></td>
<td><p>Active low design reset</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">mprj_io[20:5]</span></code></p></td>
<td><p>AD[15:0]</p></td>
<td><p>IO</p></td>
<td><p>16-bit bus multiplexing addresses and data</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">mprj_io[21]</span></code></p></td>
<td><p>LE LO</p></td>
<td><p>O</p></td>
<td><p>Latch enable for low (bits 0 - 15) address word</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">mprj_io[22]</span></code></p></td>
<td><p>LE HI</p></td>
<td><p>O</p></td>
<td><p>Latch enable for high (bits 16 - 30) address word</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">mprj_io[23]</span></code></p></td>
<td><p>BDIR</p></td>
<td><p>O</p></td>
<td><p>Indicates direction of bus pins, low = output, high = input</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">mprj_io[24]</span></code></p></td>
<td><p>OE</p></td>
<td><p>O</p></td>
<td><p>Active low memory Output Enable</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">mprj_io[25]</span></code></p></td>
<td><p>WE LO</p></td>
<td><p>O</p></td>
<td><p>Active low memory Write Enable for low byte (bits 0 - 7)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">mprj_io[26]</span></code></p></td>
<td><p>WE HI</p></td>
<td><p>O</p></td>
<td><p>Active low memory Write Enable for high byte (bits 8 - 15)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">mprj_io[27]</span></code></p></td>
<td><p>SCLK</p></td>
<td><p>O</p></td>
<td><p>SPI master port Serial Clock</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">mprj_io[28]</span></code></p></td>
<td><p>SDI</p></td>
<td><p>I</p></td>
<td><p>SPI master port Serial Data In</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">mprj_io[29]</span></code></p></td>
<td><p>SDO</p></td>
<td><p>O</p></td>
<td><p>SPI master port Serial Data Out</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">mprj_io[30]</span></code></p></td>
<td><p>TXD</p></td>
<td><p>O</p></td>
<td><p>UART Serial Data Out</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">mprj_io[31]</span></code></p></td>
<td><p>RXD</p></td>
<td><p>I</p></td>
<td><p>UART Serial Data In</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">mprj_io[37:32]</span></code></p></td>
<td><p>PA[5:0]</p></td>
<td><p>IO</p></td>
<td><p>Programmable GPIO port</p></td>
</tr>
</tbody>
</table>
</section>
<section id="memory-bus">
<h2>Memory Bus<a class="headerlink" href="#memory-bus" title="Link to this heading"></a></h2>
<p>The main feature of this design is the 16-bit wide Address/Data bus which transfers address and data information 16 bits at a time. Externally, the chip addresses memory as an array of 16-bit values. Each address emitted is a 16-bit word address with a length of 31 bits. As both halves of the address are multiplexed onto the same pins, transparent latches (ie 74HC573) need to be used to latch the full address. The pins <code class="docutils literal notranslate"><span class="pre">LE_LO</span></code> and <code class="docutils literal notranslate"><span class="pre">LE_HI</span></code> can be used as enables for these latches to first pass through, then latch the address halves.</p>
<p>This is then followed by the actual data read or write. A low level on <code class="docutils literal notranslate"><span class="pre">OE</span></code> indicates a read. However, because RISC-V has instructions for only storing single bytes, it is possible that only one half of a 16-bit word needs to be modified. The outputs <code class="docutils literal notranslate"><span class="pre">WE</span> <span class="pre">LO</span></code> and <code class="docutils literal notranslate"><span class="pre">WE</span> <span class="pre">HI</span></code> indicate which halves of the currently addressed word need to be updated:</p>
<table class="docutils align-default" id="riscv-we-states">
<caption><span class="caption-number">Table 9 </span><span class="caption-text">Possible Write-Enable states</span><a class="headerlink" href="#riscv-we-states" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p><code class="docutils literal notranslate"><span class="pre">WE</span> <span class="pre">HI</span></code></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">WE</span> <span class="pre">LO</span></code></p></th>
<th class="head"><p>Halves updated</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">1</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">1</span></code></p></td>
<td><p>Neither (no write)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">1</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0</span></code></p></td>
<td><p>Low half, bits 0 - 7</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">0</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">1</span></code></p></td>
<td><p>High half, bits 8 - 15</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">0</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0</span></code></p></td>
<td><p>Both halves, bits 0 - 15</p></td>
</tr>
</tbody>
</table>
<p>Most parallel RAM ICs with a 16-bit organization support this addressing scheme with two separate write enable signals, so no additional logic should be required to connect memory to this design.</p>
<p>Example timing diagram of the fetch and execute of a 32-bit store instruction, showing most possible bus states:</p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{signal: [
{name: 'CLK', wave: 'n...........', period: 2},
{name: 'LE LO', wave: '010....10....10....10...'},
{name: 'LE HI', wave: '0..10..........10.......'},
{name: 'OE', wave: '1....0.1.0.1............'},
{name: 'WE LO', wave: '1................01..01.'},
{name: 'WE HI', wave: '1................01..01.'},
{name: 'AD[15:0]', wave: 'z5.6.7.5.7.z.5.6.8.5.8.z', data: 'addr[15:0] addr[30:16] data[15:0] addr[15:0] data[31:16] addr[15:0] addr[30:16] data[15:0] addr[15:0] data[31:16]'},
{name: 'BDIR', wave: '10...1.0.1...0.........1'}
],config: { hscale: 1 }}
</script>
</div>
<p>Note <code class="docutils literal notranslate"><span class="pre">reg_mprj_settings</span></code> == 2 in this example.</p>
</section>
<section id="peripherals">
<h2>Peripherals<a class="headerlink" href="#peripherals" title="Link to this heading"></a></h2>
<p>There are several on-die peripherals included with this design, all of which are accessed via memory mapped registers starting at address <code class="docutils literal notranslate"><span class="pre">FFFFFF00h</span></code>. These final 256 addresses of memory are used to address these registers, which are all 32-bit wide. Only 32-bit load/store instructions may be used to access them. Accessing any one of these memory locations will not trigger signals on <code class="docutils literal notranslate"><span class="pre">OE</span></code>, <code class="docutils literal notranslate"><span class="pre">WE</span> <span class="pre">LO</span></code> or <code class="docutils literal notranslate"><span class="pre">WE</span> <span class="pre">HI</span></code>, though the address may partially be latched by <code class="docutils literal notranslate"><span class="pre">LE</span> <span class="pre">LO</span></code>.</p>
<section id="serial-ports">
<h3>Serial ports<a class="headerlink" href="#serial-ports" title="Link to this heading"></a></h3>
<p>There are two serial ports accessible to the CPU:</p>
<p>The UART, exposed through pins <code class="docutils literal notranslate"><span class="pre">RXD</span></code> and <code class="docutils literal notranslate"><span class="pre">TXD</span></code>, a full-duplex asynchronous serial port that can send and receive 8-N-1 data frames at a custom baudrate. It is possible for the UART to trigger an interrupt upon receipt of a character on <code class="docutils literal notranslate"><span class="pre">RXD</span></code>.</p>
<p>A SPI master port, exposed through pins <code class="docutils literal notranslate"><span class="pre">SDI</span></code>, <code class="docutils literal notranslate"><span class="pre">SDO</span></code> and <code class="docutils literal notranslate"><span class="pre">SCLK</span></code> also with a custom bitclock.</p>
<p><code class="docutils literal notranslate"><span class="pre">SDIV</span></code> - SPI Clock Divider</p>
<p>Address: <code class="docutils literal notranslate"><span class="pre">FFFFFF00h</span></code></p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{ "reg": [
  {"name": "SDIV[7:0]", "bits": 8},{"type": "1", "bits": 24}],
 "config": {"hspace": 700}
}
</script>
</div>
<p>This register defines the amount by which the processor clock is divided to arrive at the SPI serial clock. The SPI serial clock will be equal to <code class="docutils literal notranslate"><span class="pre">CPU</span> <span class="pre">clock</span> <span class="pre">/</span> <span class="pre">(SDIV</span> <span class="pre">*</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">1)</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">SDR</span></code> - SPI Data Register</p>
<p>Address: <code class="docutils literal notranslate"><span class="pre">FFFFFF04h</span></code></p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{ "reg": [
  {"name": "SDR[7:0]", "bits": 8},{"type": "1", "bits": 24}],
 "config": {"hspace": 700}
}
</script>
</div>
<p>This register is used to transfer bytes in and out of the SPI port. Writing this register immediately begins a SPI full-duplex transfer. The SPI busy flag is set and the written data byte is serially transmitted at the same time as a data byte is received. No further writes to this location should be made while the busy flag is set.</p>
<p>Once the transfer is complete as indicated by the busy flag becoming clear, the received data byte can be obtained by reading from this location.</p>
<p><code class="docutils literal notranslate"><span class="pre">UDIV</span></code> - UART Clock Divider</p>
<p>Address: <code class="docutils literal notranslate"><span class="pre">FFFFFF08h</span></code></p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{ "reg": [
  {"name": "UDIV[15:0]", "bits": 16},{"type": "1", "bits": 16}],
 "config": {"hspace": 700}
}
</script>
</div>
<p>This register defines the amount by which the processor clock is divided to arrive at the UART bitclock. The UART bitclock will be equal to <code class="docutils literal notranslate"><span class="pre">CPU</span> <span class="pre">clock</span> <span class="pre">/</span> <span class="pre">(UDIV</span> <span class="pre">+</span> <span class="pre">1)</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">UDR</span></code> - UART Data Register</p>
<p>Address: <code class="docutils literal notranslate"><span class="pre">FFFFFF0Ch</span></code></p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{ "reg": [
  {"name": "UDR[7:0]", "bits": 8},{"type": "1", "bits": 24}],
 "config": {"hspace": 700}
}
</script>
</div>
<p>This register address is used to provide the UART data to transmit as well as read received data. When written to, the UART will immediatly activate, set its busy flag and begin serially transmitting the provided data byte. No further writes to this location should be made while the busy flag is set.</p>
<p>When read, the UDR will contain the latest data byte received by the UART. Accessing this location with a read will also clear the <code class="docutils literal notranslate"><span class="pre">UHB</span></code> flag.</p>
<p><code class="docutils literal notranslate"><span class="pre">STAT</span></code> - Serial Status Register</p>
<p>Address: <code class="docutils literal notranslate"><span class="pre">FFFFFF10h</span></code></p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{ "reg": [
  {"name": "UART BUSY", "bits": 1},{"name": "UHB", "bits": 1},{"name": "SPI BUSY", "bits": 1},{"type": "1", "bits": 29}],
 "config": {"hspace": 2800}
}
</script>
</div>
<p>This read-only register contains status information for both the UART and SPI master ports. Besides their respective busy flags, the STAT also contains <code class="docutils literal notranslate"><span class="pre">UHB</span></code>, a flag which indicates that the UART has received a data byte which has not yet been read out of the <code class="docutils literal notranslate"><span class="pre">UDR</span></code>.</p>
</section>
<section id="gpio-port">
<h3>GPIO Port<a class="headerlink" href="#gpio-port" title="Link to this heading"></a></h3>
<p>The pins <code class="docutils literal notranslate"><span class="pre">PA0</span></code> through <code class="docutils literal notranslate"><span class="pre">PA5</span></code> form a 6-bit wide general-purpose IO port with individually programmable direction and data.</p>
<p><code class="docutils literal notranslate"><span class="pre">DDRA</span></code> - Data Direction Register A</p>
<p>Address: <code class="docutils literal notranslate"><span class="pre">FFFFFF14h</span></code></p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{ "reg": [
  {"name": "DDRA[5:0]", "bits": 6},{"type": "1", "bits": 26}],
 "config": {"hspace": 700}
}
</script>
</div>
<p>This register allows individually changing each port pin between an input and output port. A logic one equals an output port while a logic zero equals an input port. This register resets to a value of 0.</p>
<p><code class="docutils literal notranslate"><span class="pre">PORTA</span></code> - Port Data Register A</p>
<p>Address: <code class="docutils literal notranslate"><span class="pre">FFFFFF18h</span></code></p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{ "reg": [
  {"name": "PORTA[5:0]", "bits": 6},{"type": "1", "bits": 26}],
 "config": {"hspace": 700}
}
</script>
</div>
<p>This register allows individually setting the state of every port bit configured as an output port. This register resets to a value of 0.</p>
<p><code class="docutils literal notranslate"><span class="pre">PINA</span></code> - Port Input A</p>
<p>Address: <code class="docutils literal notranslate"><span class="pre">FFFFFF1Ch</span></code></p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{ "reg": [
  {"name": "PINA[5:0]", "bits": 6},{"type": "1", "bits": 26}],
 "config": {"hspace": 700}
}
</script>
</div>
<p>This address returns the states of all port bits configured as inputs. It is read-only.</p>
</section>
<section id="timers">
<h3>Timers<a class="headerlink" href="#timers" title="Link to this heading"></a></h3>
<p>There are two 32-bit timers, Timer 0 and Timer 1, with customizable prescalers present, one of which is capable of generating interrupts. Their counts may be set and read by the CPU at any time.</p>
<p>Each timer counts up from 0 at the rate defined by <code class="docutils literal notranslate"><span class="pre">TDIVx</span></code> until its value reaches <code class="docutils literal notranslate"><span class="pre">TTOPx</span></code>, at which point it resets back to 0 and continues counting up from there. Timer 1 may optionally generate a interrupt each time it resets in this manner.</p>
<p><code class="docutils literal notranslate"><span class="pre">TDIV0</span></code> - Timer Clock Div 0 (prescaler)</p>
<p>Address: <code class="docutils literal notranslate"><span class="pre">FFFFFF2Ch</span></code></p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{ "reg": [
  {"name": "TDIV0[31:0]", "bits": 32}],
 "config": {"hspace": 700}
}
</script>
</div>
<p>This register defines the amount by which the processor clock is divided to arrive at the timer count rate for Timer 0. The rate will be equal to <code class="docutils literal notranslate"><span class="pre">CPU</span> <span class="pre">clock</span> <span class="pre">/</span> <span class="pre">max(TDIV0,</span> <span class="pre">1)</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">TDIV1</span></code> - Timer Clock Div 1 (prescaler)</p>
<p>Address: <code class="docutils literal notranslate"><span class="pre">FFFFFF30h</span></code></p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{ "reg": [
  {"name": "TDIV1[31:0]", "bits": 32}],
 "config": {"hspace": 700}
}
</script>
</div>
<p>This register defines the amount by which the processor clock is divided to arrive at the timer count rate for Timer 1. The rate will be equal to <code class="docutils literal notranslate"><span class="pre">CPU</span> <span class="pre">clock</span> <span class="pre">/</span> <span class="pre">max(TDIV1,</span> <span class="pre">1)</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">TTOP0</span></code> - Timer Top 0</p>
<p>Address: <code class="docutils literal notranslate"><span class="pre">FFFFFF34h</span></code></p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{ "reg": [
  {"name": "TTOP0[31:0]", "bits": 32}],
 "config": {"hspace": 700}
}
</script>
</div>
<p>The maximum value Timer 0 will count up to before reseting to 0.</p>
<p><code class="docutils literal notranslate"><span class="pre">TTOP1</span></code> - Timer Top 1</p>
<p>Address: <code class="docutils literal notranslate"><span class="pre">FFFFFF38h</span></code></p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{ "reg": [
  {"name": "TTOP1[31:0]", "bits": 32}],
 "config": {"hspace": 700}
}
</script>
</div>
<p>The maximum value Timer 1 will count up to before reseting to 0.</p>
<p><code class="docutils literal notranslate"><span class="pre">TMR0</span></code> - Timer 0</p>
<p>Address: <code class="docutils literal notranslate"><span class="pre">FFFFFF3Ch</span></code></p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{ "reg": [
  {"name": "TMR0[31:0]", "bits": 32}],
 "config": {"hspace": 700}
}
</script>
</div>
<p>This register holds the actual value of Timer 0. Reading it will get the current timer count. Writing it will set it, with the timer continuing to count up from the new value unless said value is greater than or equal to <code class="docutils literal notranslate"><span class="pre">TTOP0</span></code>, in which case it will immediately reset to 0 the next time the prescaler expires and the timer is updated.</p>
<p><code class="docutils literal notranslate"><span class="pre">TMR1</span></code> - Timer 1</p>
<p>Address: <code class="docutils literal notranslate"><span class="pre">FFFFFF40h</span></code></p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{ "reg": [
  {"name": "TMR1[31:0]", "bits": 32}],
 "config": {"hspace": 700}
}
</script>
</div>
<p>This register holds the actual value of Timer 1. Reading it will get the current timer count. Writing it will set it, with the timer continuing to count up from the new value unless said value is greater than or equal to <code class="docutils literal notranslate"><span class="pre">TTOP1</span></code>, in which case it will immediately reset to 0 the next time the prescaler expires and the timer is updated.</p>
</section>
</section>
<section id="interrupts">
<h2>Interrupts<a class="headerlink" href="#interrupts" title="Link to this heading"></a></h2>
<p>Tholin’s RISC-V supports a basic interrupt model where one of several interrupt sources can generate an Interrupt Request (IRQ) which will cause the CPU to branch to a new location defined by <code class="docutils literal notranslate"><span class="pre">IVEC</span></code> upon completion of the current instruction, which is intended to hold an interrupt handler. Unlike a regular JAL instruction, however, the old Program Counter value is moved into one of the memory-mapped registers instead of a general-purpose register, for use in an eventual return from the interrupt handler. The custom <code class="docutils literal notranslate"><span class="pre">iret</span></code> instruction needs to be used for this purpose. No other action is taken, and the general-purpose registers must be backed up to memory in software, as needed.</p>
<p>Before any interrupts can be generated, bits in <code class="docutils literal notranslate"><span class="pre">IEN</span></code> need to be set to enable individual interrupts and the custom <code class="docutils literal notranslate"><span class="pre">sei</span></code> instruction executed to enable interrupts globally. <code class="docutils literal notranslate"><span class="pre">cli</span></code> can be used to disable interrupts globally again, independent of the settings in <code class="docutils literal notranslate"><span class="pre">IEN</span></code>. After reset, <code class="docutils literal notranslate"><span class="pre">IEN</span></code> and the global interrupt enable are both clear. This global interrupt enable exists to prevent further interrupts from triggering while another is already being handled, as interrupts cannot stack. It is cleared at the beginning of an interrupt.</p>
<p>As there are several IRQ sources, numbered <code class="docutils literal notranslate"><span class="pre">IRQ0</span></code> through <code class="docutils literal notranslate"><span class="pre">IRQ2</span></code>, but only one interrupt can be handled at one time, each IRQ is actually a latch which is set when an interrupt is triggered. Upon completion of a interrupt handler, further interrupts will be triggered immediately until all IRQ latches are clear.</p>
<p>The clearing of IRQ latches is not automatic and needs to be done in software by writing to a specific memory-mapped register. If this is not done, the interrupt logic will mistakenly believe the interrupt has not yet been served and re-trigger it indefinitely. IRQs can also be cleared outside the interrupt handler code to effectively “cancel” that interrupt. Clearing an interrupt enable in <code class="docutils literal notranslate"><span class="pre">IEN</span></code> also immediately clears that IRQ.</p>
<p>Of further note is that the CPU does not distinguish between multiple interrupt handlers and will always branch to <code class="docutils literal notranslate"><span class="pre">IVEC</span></code>. Instead, it is possible for the CPU to read the <code class="docutils literal notranslate"><span class="pre">INUM</span></code> register to know which is the current IRQ being handled and jump to an appropriate subroutine.</p>
<p>The following interrupt sources exist:</p>
<section id="external-interrupt">
<h3>External Interrupt<a class="headerlink" href="#external-interrupt" title="Link to this heading"></a></h3>
<p>IRQ #: <code class="docutils literal notranslate"><span class="pre">IRQ0</span></code></p>
<p>When the external interrupt is enabled in <code class="docutils literal notranslate"><span class="pre">IEN</span></code>, a low-to-high transition on pin <code class="docutils literal notranslate"><span class="pre">PA5</span></code> triggers this interrupt. <code class="docutils literal notranslate"><span class="pre">PA5</span></code> must be set to an input using <code class="docutils literal notranslate"><span class="pre">DDRA</span></code> beforehand. The state of the <code class="docutils literal notranslate"><span class="pre">PA5</span></code> input can still be read through <code class="docutils literal notranslate"><span class="pre">PINA</span></code>.</p>
<p>The interrupt must be cleared by writing a zero to address <code class="docutils literal notranslate"><span class="pre">FFFFFF1Ch</span></code>.</p>
</section>
<section id="timer-1-interrupt">
<h3>Timer 1 Interrupt<a class="headerlink" href="#timer-1-interrupt" title="Link to this heading"></a></h3>
<p>IRQ #: <code class="docutils literal notranslate"><span class="pre">IRQ1</span></code></p>
<p>When enabled in <code class="docutils literal notranslate"><span class="pre">IEN</span></code>, Timer 1 will generate this interrupt every time it reaches <code class="docutils literal notranslate"><span class="pre">TTOP1</span></code> and resets to 0.</p>
<p>The interrupt must be cleared by writing a zero to address <code class="docutils literal notranslate"><span class="pre">FFFFFF44h</span></code>.</p>
</section>
<section id="uart-interrupt">
<h3>UART Interrupt<a class="headerlink" href="#uart-interrupt" title="Link to this heading"></a></h3>
<p>IRQ #: <code class="docutils literal notranslate"><span class="pre">IRQ2</span></code></p>
<p>When enabled in <code class="docutils literal notranslate"><span class="pre">IEN</span></code>, the UART will generate this interrupt whenever a complete character has been received and is now available to be read out of the <code class="docutils literal notranslate"><span class="pre">UDR</span></code>.</p>
<p>The interrupt must be cleared by reading <code class="docutils literal notranslate"><span class="pre">UDR</span></code>.</p>
</section>
<section id="registers">
<h3>Registers<a class="headerlink" href="#registers" title="Link to this heading"></a></h3>
<p>There are several memory-mapped registers involved in controlling the interrupt logic. These are:</p>
<p><code class="docutils literal notranslate"><span class="pre">IVEC</span></code> - Interrupt Vector Address</p>
<p>Address: <code class="docutils literal notranslate"><span class="pre">FFFFFF20h</span></code></p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{ "reg": [
  {"type": "1", "bits": 2},{"name": "IVEC[31:2]", "bits": 30}],
 "config": {"hspace": 700}
}
</script>
</div>
<p>This register holds the address of the first instruction of the interrupt handler. As RISC-V requires all instructions be alligned to 32-bit words, the least-significant two bits of this register are always 0.</p>
<p><code class="docutils literal notranslate"><span class="pre">INUM</span></code> - Current Interrupt Number</p>
<p>Address: <code class="docutils literal notranslate"><span class="pre">FFFFFF24h</span></code></p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{ "reg": [
  {"name": "INUM[1:0]", "bits": 2},{"type": "1", "bits": 30}],
 "config": {"hspace": 1200}
}
</script>
</div>
<p>This read-only register holds the number of the current IRQ being handled plus one. This can be used by interrupt handler code to learn which exact interrupt it is handling, and jump to a appropriate subroutine. If the CPU is not currently handling an interrupt, this register reads zero.</p>
<p><code class="docutils literal notranslate"><span class="pre">IEN</span></code> - Interrupt Enables</p>
<p>Address: <code class="docutils literal notranslate"><span class="pre">FFFFFF28h</span></code></p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{ "reg": [
  {"name": "IRQ0EN", "bits": 1},{"name": "IRQ1EN", "bits": 1},{"name": "IRQ2EN", "bits": 1},{"type": "1", "bits": 29}],
 "config": {"hspace": 1900}
}
</script>
</div>
<p>This register contains three bits that individually enable one of the three interrupts. It is cleared to zero on reset.</p>
<p><code class="docutils literal notranslate"><span class="pre">PREVPC</span></code> - Previous Program Counter Backup</p>
<p>Address: <code class="docutils literal notranslate"><span class="pre">FFFFFF48h</span></code></p>

<div style="overflow-x:auto">
<script type="WaveDrom">
{ "reg": [
  {"type": "1", "bits": 2},{"name": "PREVPC[31:2]", "bits": 30}],
 "config": {"hspace": 700}
}
</script>
</div>
<p>This register is used as a location to back up the previous Program Counter value to, at the beginning of an interrupt. It is read-only.</p>
</section>
<section id="the-iret-instruction">
<h3>The <code class="docutils literal notranslate"><span class="pre">iret</span></code> instruction<a class="headerlink" href="#the-iret-instruction" title="Link to this heading"></a></h3>
<p>Opcode: <code class="docutils literal notranslate"><span class="pre">26D00073h</span></code></p>
<p>This is the instruction used to return from interrupts. It restores the Program Counter value from the backup made at the beginning of the interrupt and then <cite>inverts</cite> the global interrupt enable. As the global interrupt enable is cleared at the beginning of an interrupt, this has the effect of enabling it again, allowing further interrupts to take place.</p>
</section>
<section id="the-sei-instruction">
<h3>The <code class="docutils literal notranslate"><span class="pre">sei</span></code> instruction<a class="headerlink" href="#the-sei-instruction" title="Link to this heading"></a></h3>
<p>Opcode: <code class="docutils literal notranslate"><span class="pre">00700073h</span></code></p>
<p>This instruction sets the global interrupt enable.</p>
</section>
<section id="the-cli-instruction">
<h3>The <code class="docutils literal notranslate"><span class="pre">cli</span></code> instruction<a class="headerlink" href="#the-cli-instruction" title="Link to this heading"></a></h3>
<p>Opcode: <code class="docutils literal notranslate"><span class="pre">00800073h</span></code></p>
<p>This instruction clears the global interrupt enable.</p>
</section>
</section>
<section id="custom-settings">
<h2>Custom Settings<a class="headerlink" href="#custom-settings" title="Link to this heading"></a></h2>
<p>This design makes use of the <code class="docutils literal notranslate"><span class="pre">reg_mprj_settings</span></code> wishbone register. Specifically, it can be used to change the behavior of the <code class="docutils literal notranslate"><span class="pre">WE</span> <span class="pre">HI</span></code> and <code class="docutils literal notranslate"><span class="pre">WE</span> <span class="pre">LO</span></code> pins to change the width and timing of them, which may be required depending on the exact memory IC used with the design. There are three possible settings (the default is zero):</p>
<p><code class="docutils literal notranslate"><span class="pre">0</span></code>: <code class="docutils literal notranslate"><span class="pre">WE</span> <span class="pre">LO</span></code>/<code class="docutils literal notranslate"><span class="pre">WE</span> <span class="pre">HI</span></code> is active for a full clock cycle.</p>
<p><code class="docutils literal notranslate"><span class="pre">1</span></code>: <code class="docutils literal notranslate"><span class="pre">WE</span> <span class="pre">LO</span></code>/<code class="docutils literal notranslate"><span class="pre">WE</span> <span class="pre">HI</span></code> is only active when the clock is low.</p>
<p><code class="docutils literal notranslate"><span class="pre">2</span></code>: <code class="docutils literal notranslate"><span class="pre">WE</span> <span class="pre">LO</span></code>/<code class="docutils literal notranslate"><span class="pre">WE</span> <span class="pre">HI</span></code> is only active when the clock is high.</p>
</section>
</section>

    <script type="text/javascript">
        function init() {
            WaveDrom.ProcessAll();
        }
        window.onload = init;
    </script>

           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ue14500.html" class="btn btn-neutral float-left" title="UE14500" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="rejs_designs.html" class="btn btn-neutral float-right" title="Rejunity’s Designs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Tholin.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>